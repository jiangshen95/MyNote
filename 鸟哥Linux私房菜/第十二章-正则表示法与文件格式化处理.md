# 正则表示法
正规表示法就是处理字串的方法，他是以行为单位来进行字串的处理行为， 正规表示法透过一些特殊符号的辅助，可以让使用者轻易的达到『搜寻/删除/取代』某特定字串的处理程序。正规表示法基本上是一种『表示法』， 只要工具程序支持这种表示法，那么该工具程序就可以用来作为正规表示法的字串处理之用。但例如 cp, ls 等命令并未支持正规表示法， 所以就只能使用 bash 自己本身的万用字节而已。  
正规表示法依照不同的严谨程度分为：基础正规表示法与延伸正规表示法。延伸型正规表示法除了简单的一组字串处理之外，还可以作群组的字串处理，藉由特殊的『 ( 』与『 | 』等字节的协助，就能实现『或(or)』等功能。
# 基础正规表示法
对字节排序有影响的语系数据就会对正规表示法的结果有影响。
## 语系对正规表示法的影响
不同语系的编码不同，字符排序也不同，使用正则表示法撷取的结果可能也不同。使用 [LANG=C] 这个语系。  
特殊符号的意义：
特殊符号|代表意义
:---:|:---:
[:alnum:]|代表英文大小写字节及数字，亦即 0-9, A-Z, a-z
[:alpha:]|代表任何英文大小写字节，亦即 A-Z, a-z
[:blank:]|代表空白键与 [Tab] 按键两者
[:cntrl:]|代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等
[:digit:]|代表数字而已，亦即 0-9
[:graph:]|除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键
[:lower:]|代表小写字节，亦即 a-z
[:print:]|代表任何可以被列印出来的字节
[:punct:]|代表标点符号 (punctuation symbol)，亦即：" ' ? ! ; : # $...
[:upper:]|代表大写字节，亦即 A-Z
[:space:]|任何会产生空白的字节，包括空白键, [Tab], CR 等等
[:xdigit:]|代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节
## grep 的进阶
『grep 在数据中查寻一个字串时，是以 "整行" 为单位来进行数据的撷取的』在 ~/.bashrc 内加上这行：『alias grep='grep --color=auto'』再以『 source ~/.bashrc 』来立即生效即可, 这样每次运行 grep 都会自动加上颜色显示
```
[root@www ~]# grep [-A] [-B] [--color=auto] '搜寻字串' filename
选项与参数：
-A ：后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；
-B ：后面可加数字，为 befer 的意思，除了列出该行外，前面的 n 行也列出来；
--color=auto 可将正确的那个撷取数据列出颜色
```
## 基础正规表示法
* . (小数点)：代表『一定有一个任意字节』的意思；
* \* (星星号)：代表『重复前一个字节， 0 到无穷多次』的意思，为组合形态
* 限制一个范围区间内的重复字节数，使用限定范围的字符 {} 。因为 { 与 } 在 shell 是有特殊意义的，所以使用时必须要用跳脱字符 \ 。
## 基础正则表示法字符汇整 (characters)
RE 字符|意义与范例
:---:|:---:
^word|意义：待搜寻的字串(word)在行首！<br>范例：搜寻行首为 # 开始的那一行，并列出行号<br>grep -n '^#' regular_express.txt
word$|意义：待搜寻的字串(word)在行尾！<br>范例：将行尾为 ! 的那一行列印出来，并列出行号<br>grep -n '!$' regular_express.txt
.|意义：代表『一定有一个任意字节』的字符！<br>范例：搜寻的字串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 e 中间『一定』仅有一个字节，而空白字节也是字节！<br>grep -n 'e.e' regular_express.txt
\\|意义：跳脱字符，将特殊符号的特殊意义去除！<br>范例：搜寻含有单引号 ' 的那一行！<br>grep -n \' regular_express.txt
\*|意义：重复零个到无穷多个的前一个 RE 字符<br>范例：找出含有 (es) (ess) (esss) 等等的字串，注意，因为 * 可以是 0 个，所以 es 也是符合带搜寻字串。另外，因为 * 为重复『前一个 RE 字符』的符号， 因此，在 * 之前必须要紧接著一个 RE 字符喔！例如任意字节则为 『.\*』 ！<br>grep -n 'ess*' regular_express.txt
[list]|意义：字节集合的 RE 字符，里面列出想要撷取的字节！<br>范例：搜寻含有 (gl) 或 (gd) 的那一行，需要特别留意的是，在 [] 当中『谨代表一个待搜寻的字节』， 例如『 a[afl]y 』代表搜寻的字串可以是 aay, afy, aly 即 [afl] 代表 a 或 f 或 l 的意思！<br>grep -n 'g[ld]' regular_express.txt
[n1-n2]|意义：字节集合的 RE 字符，里面列出想要撷取的字节范围！<br>范例：搜寻含有任意数字的那一行！需特别留意，在字节集合 [] 中的减号 - 是有特殊意义的，他代表两个字节之间的所有连续字节！但这个连续与否与 ASCII 编码有关，因此，你的编码需要配置正确(在 bash 当中，需要确定 LANG 与 LANGUAGE 的变量是否正确！) 例如所有大写字节则为 [A-Z]<br>grep -n '[A-Z]' regular_express.txt
[^list]|意义：字节集合的 RE 字符，里面列出不要的字串或范围！<br>范例：搜寻的字串可以是 (oog) (ood) 但不能是 (oot) ，那个 ^ 在 [] 内时，代表的意义是『反向选择』的意思。 例如，我不要大写字节，则为 [^A-Z]。但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜寻，却发现该文件内的所有行都被列出，为什么？因为这个 [^A-Z] 是『非大写字节』的意思， 因为每一行均有非大写字节，例如第一行的 "Open Source" 就有 p,e,n,o.... 等等的小写字<br>grep -n 'oo[^t]' regular_express.txt
\{n,m\}|意义：连续 n 到 m 个的『前一个 RE 字符』<br>意义：若为 \{n\} 则是连续 n 个的前一个 RE 字符，<br>意义：若是 \{n,\} 则是连续 n 个以上的前一个 RE 字符！ <br>范例：在 g 与 g 之间有 2 个到 3 个的 o 存在的字串，亦即 (goog)(gooog)<br>grep -n 'go\{2,3\}g' regular_express.txt

## sed 工具
sed 本身也是管线命令，还可以将数据进行取代、删除、新增、撷取特定行等等的功能。
```
[root@www ~]# sed [-nefr] [动作]
选项与参数：
-n  ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 
      的数据一般都会被列出到屏幕上。但如果加上 -n 参数后，则只有经过
      sed 特殊处理的那一行(或者动作)才会被列出来。
-e  ：直接在命令列模式上进行 sed 的动作编辑；
-f  ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 
      sed 动作；
-r  ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)
-i  ：直接修改读取的文件内容，而不是由屏幕输出。

动作说明：  [n1[,n2]]function
n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作
         是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』

function 有底下这些功能：
a   ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
c   ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
d   ：删除，因为是删除啊，所以 d 后面通常不接任何内容；
i   ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
p   ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
s   ：取代，可以直接进行取代的工作！通常这个 s 的动作可以搭配
      正规表示法！例如 1,20s/old/new/g 就是啦！
```
### 以行为单位的新增/删除功能
```
将 /etc/passwd 的内容列出并且列印行号，同时，删除 2-5 行
nl /etc/passwd | sed '2,5d'
# sed 后面接的动作，务必以“两个单引号括住”。set '2,$d' 代表删除到最后一行，'2d' 代表删除第二行

在第二行后(亦即加在第三行)加上 [drink tea?]字样
nl /etc/passwd | sed '2a drink tea'
# 使用 sed '2i drink' 加到第二行前面

在第二行后面加入两行字
nl /etc/passwd | sed '2a Drink tea or .....\
> drink beer ?'
# 新增不止一行，每一行之间都必须要以反斜线【\】来进行新行的添加
```
### 以行为为单位的取代与显示功能
```
将第 2-5 行的内容取代成为【No 2-5 number】
nl /etc/passwd | sed '2,5c No 2-5 number'

仅列出 /etc/passwd 文件内容的第 5-7 行
nl /etc/passwd | sed -n '5,7p'
```
### 部分数据的搜寻并取代的功能
```
sed 's/要被取代的字符串/新的字符串/g'
# 可以使用正则表示法
```
### 直接修改文件内容(危险动作)
```
利用 sed 将 test.txt 内每一行结尾若为 . 则换成 !
sed -i 's/\.$/\!/g' test.txt

利用 sed 在最后一行加入【# This is a test!】
sed -i '$a # This is a test' test.txt
```

# 延伸正规表示法
延伸型正规表示法可以透过群组功能『 | 』来进行一次搜寻，那个在单引号内的管线意义为『或 or』。grep 默认仅支持基础正规表示法，如果要使用延伸型正规表示法，可以使用 grep -E，更建议直接使用 egrep。
RE 字符|意义与范例
:---:|:---:
+|意义：重复『一个或一个以上』的前一个 RE 字符<br>范例：搜寻 (god) (good) (goood)... 等等的字串。 那个 o+ 代表『一个以上的 o 』<br>egrep -n 'go+d' regular_express.txt
?|意义：『零个或一个』的前一个 RE 字符<br>范例：搜寻 (gd) (god) 这两个字串。 那个 o? 代表『空的或 1 个 o 』。<br>egrep -n 'go?d' regular_express.txt
\||意义：用或( or )的方式找出数个字串<br>范例：搜寻 gd 或 good 这两个字串，注意，是『或』！ <br>egrep -n 'gd\|good' regular_express.txt<br>egrep -n 'gd\|good\|dog' regular_express.txt
()|意义：找出『群组』字串<br>范例：搜寻 (glad) 或 (good) 这两个字串，因为 g 与 d 是重复的，所以， 我就可以将 la 与 oo 列于 ( ) 当中，并以 \| 来分隔开来<br>egrep -n 'g(la\|oo)d' regular_express.txt
()+|意义：多个重复群组的判别<br>范例：要找开头是 A 结尾是 C ，中间有一个以上的 "xyz" 字串<br>echo 'AxyzxyzxyzxyzC' \| egrep 'A(xyz)+C'

# 文件的格式化与相关处理
透过数据流重导向配合 printf 功能以及 awk 命令，可以让信息以想要的格式输出。
## 格式化列印：printf
列印格式管理员 printf 可以帮我们将数据输出的结果格式化，而且支持一些特殊的字符。
```
[root@www ~]# printf '列印格式' 实际内容
选项与参数：
关于格式方面的几个特殊样式：
       \a    警告声音输出
       \b    倒退键(backspace)
       \f    清除屏幕 (form feed)
       \n    输出新的一行
       \r    亦即 Enter 按键
       \t    水平的 [tab] 按键
       \v    垂直的 [tab] 按键
       \xNN  NN 为两位数的数字，可以转换数字成为字节。
关于 C 程序语言内，常见的变量格式
       %ns   那个 n 是数字， s 代表 string ，亦即多少个字节；
       %ni   那个 n 是数字， i 代表 integer ，亦即多少整数码数；
       %N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数码数，
             假设我共要十个位数，但小数点有两位，即为 %10.2f

将数据的文件内容列出来姓名与成绩：(用 [tab] 分隔)
printf '%s\t %s\t %s\t %s\t \n' $(cat printf.txt)
# 由于 printf 不是管线命令，先要将文件内容提出来给 printf 作为后续的数据。

将上述数据关于第二行以后，分别以字符串、整数、小数点来显示
printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt | grep -v Name)
# %10s 代表的是一个长度为 10 个字节的字串栏位
# %5i 代表的是长度为 5 个字节的数字栏位
# %8.2f 则代表长度为 8 个字节的具有小数点的栏位，其中小数部分有两个字节宽度
```
printf 除了可以格式化处理之外，还可以依据 ASCII 的数字与图形对应来显示数据
## awk：好用的数据处理工具
相较于 sed 常用于一整行的处理，awk 则比较倾向于一行当中分成数个【栏位】来处理。更适合小型的数据处理。
```
awk '条件类型1{动作1} 条件类型2{动作2} ...' filename
# awk 后面接两个单引号并加上大括号 {} 来配置想要对数据进行处理动作。
```
awk 可以处理后续接的文件，也可以读取来自前个命令的 standard output。默认的【栏位的分隔符号为 “空白键” 或 “[tab]” 键】
```
取出账号与登陆者的 IP，且账号与 IP 之间以 [tab] 隔开
last -n 5 | awk '{print $1 "\t" $3}'
# 每一行的每个栏位都是有变量名称的，那就是 $1, $2... 等变量名称，$0 代表【一整列数据】的意思。
```
整个 awk 的处理流程是：
1. 读入第一行，并将第一行的数据填入 $0, $1, $2.... 等变量当中；
2. 依据 "条件类型" 的限制，判断是否需要进行后面的 "动作"；
3. 做完所有的动作与条件类型；
4. 若还有后续的『行』的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。

awk 是『以行为一次处理的单位』， 而『以栏位为最小的处理单位』。awk 内建变量：
变量名称|代表意义
:---:|:---:
NF|每一行 ($0) 拥有的栏位总数
NR|目前 awk 所处理的是『第几行』数据
FS|目前的分隔字节，默认是空白键
```
last -n 5 | awk '{print $1 "\t lines: " NR "\t columns: " NF}'
```
### awk 的逻辑运算字节
运算单元|代表意义
:---:|:---:
>|大于
<|小于
>=|大于或等于
<=|小于或等于
==|等于
!=|不等于
```
[root@www ~]# cat /etc/passwd | awk '{FS=":"} $3 < 10 {print $1 "\t " $3}'
root:x:0:0:root:/root:/bin/bash
bin      1
daemon   2
# 第一行没有正确显示，因为读入第一行的时候，那些变量 $1, $2... 默认还是以空白为分隔，所以虽然定义了 FS=":"，但却仅能在第二行后才能生效。
```
利用 BEGIN 关键字，预先配置 awk 的变量。除了 BEGIN 之外，还有 END 关键字。
```
cat /etc/passwd | awk 'BEGIN {FS=":"} $3 < 10 {print $1 "\t " $3}'
```
awk 还可以进行【计算功能】
```
[root@www ~]# cat pay.txt | \
> awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }
NR>=2{total = $2 + $3 + $4
printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'
```
* awk 的命令间隔：所有 awk 的动作，亦即在 {} 内的动作，如果有需要多个命令辅助时，可利用分号『;』间隔， 或者直接以 [Enter] 按键来隔开每个命令。
* 逻辑运算当中，如果是『等于』的情况，则务必使用两个等号『==』！
* 格式化输出时，在 printf 的格式配置当中，务必加上 \n ，才能进行分行！
* 与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上 $ 符号。

awk 的动作内 {} 也支持 if(条件)
## 文件对比工具
### diff
diff 就是用在比对两个文件之间的差异的，并且是以行为单位来比对。一般是用在 ASCII 纯文字档的比对上。 由于是以行为比对的单位，因此 diff 通常是用在同一的文件(或软件)的新旧版本差异上
```
[root@www ~]# diff [-bBi] from-file to-file
选项与参数：
from-file ：一个档名，作为原始比对文件的档名；
to-file   ：一个档名，作为目的比对文件的档名；
注意，from-file 或 to-file 可以 - 取代，那个 - 代表『Standard input』之意。

-b  ：忽略一行当中，仅有多个空白的差异(例如 "about me" 与 "about     me" 视为相同
-B  ：忽略空白行的差异。
-i  ：忽略大小写的不同。
```
不要用 diff 比对两个完全不相干的文件。diff 也可以比对整个目录下的差异
### cmp
 cmp 主要也是在比对两个文件，他主要利用『位组』单位去比对， 因此，可以比对 binary file。
 ```
 [root@www ~]# cmp [-s] file1 file2
选项与参数：
-s  ：将所有的不同点的位组处都列出来。因为 cmp 默认仅会输出第一个发现的不同点。
 ```
 ### patch
 【将旧文件升级成为新的文件】时，【先比较先旧版本的差异，并将差异档制作成为补丁档，再由补丁档升级旧文件】
 ```
 以 passwd.old 与 passwd.new 制作补丁文件
 diff -Naur passwd.old passwd.new > passwd.patch
 ```
 ```
 [root@www ~]# patch -pN < patch_file    <==升级
[root@www ~]# patch -R -pN < patch_file <==还原
选项与参数：
-p  ：后面可以接『取消几层目录』的意思。
-R  ：代表还原，将新的文件还原成原来旧的版本。
 ```
 ## 文件列印准备: pr
 当我们在列印的时候， 可以同时选择与配置每一页列印时的标头与页码。Linux 下列印纯文字当，可以用 pr 加入标题和页码。标题中会有『文件时间』、『文件档名』及『页码』三大项目。